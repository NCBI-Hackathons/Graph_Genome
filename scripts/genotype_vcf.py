#!/usr/bin/python3
from argparse import ArgumentParser
import sys
from os import path
from collections import defaultdict, namedtuple
import logging

logging.basicConfig(filename='genotyping_warnings.log', filemode='w', format='%(message)s')

parser = ArgumentParser()
parser.add_argument("inputfile", help = "Input file in vcf format. Only works for pseudoSample vcf.")
parser.add_argument("contig_alignment_file", help = "Alignments per chromosome. File usually generated by CRAM2VCF.pl with suffix _alignmentsPerRefID")
parser.add_argument("qid_prefix", help = "Path and prefix to *.queryIDs files")
parser.add_argument("samples", help = "File listing SampleIDs and ChromosomeIDs. E.g. 'human01  human01.h0  human01.h1' . These IDs will be related to the IDs specified with split_identify_fasta.py")
parser.add_argument("--mode", help = "[overlapping|pseudosamples*] , *:default", default = "pseudosamples")
parser.add_argument("outputfile", help="Output file in vcf format")
args = parser.parse_args()

"""

Pseudosamples format
#CHROM  POS ID  REF ALT QUAL    FILTER  INFO
chr1    10815   .   T   TC  .   PASS    .   GT:CONTIG   0/1/0/0/0/0:0,1,2,3,4,5

Overlapping format
#CHROM  POS ID  REF ALT QUAL    FILTER  INFO
chr1    10815   .   T   TC  .   PASS    CONTIG=0/2/3/4/5,1

"""
    
class Genotypes():
    def __init__(self,sids,samplefile):
        self.sampleIds = sids
        self.samplePos = {} # positions of haplotypes
        with open(samplefile) as f:
            for line in f:
                sid, sid1, sid2 = line.rstrip().split()
                if sid not in self.sampleIds:
                    print(sid + " in sampleID file not in specified ids.")
                    self = None
                pos = self.sampleIds.index(sid)*2 # diploid
                self.samplePos[sid1] = pos
                self.samplePos[sid2] = pos + 1

    def get_header(self):
        return "\t".join(self.sampleIds)

    def get_fullgenotypestring(self, gtstring):
        """ Transforms '0100' to '0|1  0|0'"""
        final = ""
        for i in range(0, len(gtstring), 2):
            gt = "." if gtstring[i] == "-" else gtstring[i]
            final += gt
            final += "|"
            gt = "." if gtstring[i+1] == "-" else gtstring[i+1]
            final += gt
            final += "\t"
        return final.rstrip()

    
    def get_genotypes_from_pseudosamples(self, chrom, position, info, table):
        """ Returns genotypes as a string for a specific variant at chrom:position """
        gtstring = ["-"] * len(self.sampleIds) * 2 # diploid
        gtst, idst = info.split(":")
        gts = gtst.split("/")
        ids = idst.split(",")
        if len(gts) != len(ids):
            logging.warning(str(gts) + " and " + str(ids) + " are not the same length at " + str(chrom) + ": " + str(position))
            return self.get_fullgenotypestring(gtstring)
        for gt, idx in zip(gts,ids):
            s = table[chrom][idx].sampleid
            curra = gtstring[self.samplePos[s]] 
            if curra == "-":
                gtstring[self.samplePos[s]] = gt
            elif curra == gt:
                logging.warning(str(s) + " is found multiple times at " + str(chrom) + ": " + str(position))
            elif curra == ".":
                logging.warning(str(s) + " is already ambigious and there is more data " + str(gt) + " at " + str(chrom) + ": " + str(position))
            elif curra != str(gt):
                logging.error(str(s) + " is both " + curra + " and " + str(gt) + " at " + str(chrom) + ": " + str(position))
                gtstring[self.samplePos[s]] = "." 
        return self.get_fullgenotypestring(gtstring)
            
            
    def get_genotypes_from_overlapping(self, chrom, position, info, table):
        """ Returns genotypes as a string for a specific variant at chrom:position """
        gtstring = ["-"] * len(self.sampleIds) * 2 # diploid 
        idfields = info.lstrip("CONTIG=").split(",") 
        for allelenr, ids in enumerate(idfields): 
            #print("ids: "  + ids) 
            if ids  == "-1": 
                continue 
            for idx in ids.split("/"): 
                s = table[chrom][idx].sampleid 
                curra = gtstring[self.samplePos[s]]  
                if curra == "-": 
                    gtstring[self.samplePos[s]] = str(allelenr) 
                elif curra == str(allelenr): 
                    logging.warning(str(s) + " is found multiple times at " + str(chrom) + ": " + str(position)) 
                elif curra == ".": 
                    logging.warning(str(s) + " is already ambigious and there is more data " + str(allelenr) + " at " + str(chrom) + ": " + str(position)) 
                elif curra != str(allelenr): 
                    logging.error(str(s) + " is both " + curra + " and " + str(allelenr) + " at " + str(chrom) + ": " + str(position)) 
                    gtstring[self.samplePos[s]] = "."  
        return self.get_fullgenotypestring(gtstring)


        

# Get utilized referenceIDs and save path to corresponding queryIDs files
idfiles = {}
with open(args.contig_alignment_file) as f:
    for line in f:
        if line.startswith("referenceID"):
            continue
        chrom = line.split()[0]
        ipath = args.qid_prefix + chrom + ".queryIDs"
        idfiles[ipath] = chrom

idPair = namedtuple('idPair', ['fullid', 'sampleid']) # used to save both the full id and the sampleID

# Get sampleIds
with open(args.samples) as f:
    sampleIds = []
    for line in f:
        sampleId = line.rstrip().split()[0]
        sampleIds.append(sampleId)



# Relate vcf IDs with sample IDs
ids_per_chrom = defaultdict(dict)
for idf, chrom in idfiles.items():
    if not path.exists(idf):
        print("Could not find " + str(idf))
        continue
    else:
        with open(idf) as f:
            for line in f:
                fid, vid = line.rstrip().split()
                ids_per_chrom[chrom][vid] = idPair(fid, fid.split("_")[0])

gto = Genotypes(sampleIds, args.samples)

# Add the haplotype information to each variant
header = ""
with open(args.outputfile, 'w+') as outf:
    with open(args.inputfile) as f:
        # First get the header and add sample names
        for line in f:
            if line.startswith('#'):
                header += line
            else:
                sheader = header.split("\n")
                newinfo = sheader[-2] + "\tFORMAT\t"+ gto.get_header()
                header = "\n".join(sheader[:-2] + ["##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">", newinfo])
                outf.write(header + "\n")
                #print(line.rstrip())
                break
        # Now add genotype information for each sample and variant
        f.seek(0)
        counter = 0
        for line in f:
            if line.startswith('#'):
                continue
            else:
                counter += 1
                if counter % 10000 == 0:
                    print(str(counter) + " variants changed", end="\r")
                sline = line.rstrip().split()
                if sline[6] == "tainted":
                    logging.warning("This variant is tainted: " + line.rstrip())
                    continue
                if args.mode == "pseudosamples":
                    genotypes = gto.get_genotypes_from_pseudosamples(sline[0],sline[1], sline[9], ids_per_chrom)
                    outf.write("\t".join(line.rstrip().split()[:-2]) + "\tGT\t" + genotypes + "\n")
                elif args.mode == "overlapping":
                    genotypes = gto.get_genotypes_from_overlapping(sline[0],sline[1], sline[9], ids_per_chrom)
                    outf.write(line.rstrip() + "\tGT\t" + genotypes + "\n")
                
